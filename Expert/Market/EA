//+------------------------------------------------------------------+

//|                                                   supertrend.mq5 |

//|                                  Copyright 2025, MetaQuotes Ltd. |

//|                                             https://www.mql5.com |

//+------------------------------------------------------------------+

#property copyright "Robot Tuan Anh - SuperTrend"

#property link      "Based on PDF description"

#property version   "1.00"

#property strict



#include <Trade\Trade.mqh>

#include <Trade\PositionInfo.mqh>

#include <Trade\HistoryOrderInfo.mqh>

#include <Trade\DealInfo.mqh>



enum ENUM_TRADING_MODE

{

    SINGLE_MODE, 

    DCA_MODE     

};



enum ENUM_SIGNAL_MODE

{

    ONE_INDICATOR,  

    TWO_INDICATORS  

};



enum ENUM_INITIAL_TRADE

{

    NONE,

    BUY_A,

    SELL_A

};



input int               MagicNumber = 123; 

input ENUM_TRADING_MODE TradingMode = DCA_MODE; 



input string            InpSuperTrendIndicatorName = "SuperTrend";

input bool              UseSuperTrend = true; 

input int               ST_Period = 10;

input double            ST_Multiplier = 3.0;



input string            InpAlphaTrendIndicatorName = "AlphaTrend";

input bool              UseAlphaTrend = false; 

input int               AT_Period = 14;

input double            AT_Multiplier = 2.0;



input ENUM_SIGNAL_MODE  SignalMode = ONE_INDICATOR; 



input double            BuyEntryDelayPips = 0.0; 

input double            SellEntryDelayPips = 0.0; 



input bool              Single_Mode_Enabled = true; 

input double            Single_BreakEvenPips = 20.0; 

input double            Single_SL_Pips = 30.0; 

input double            Single_TP_Pips = 60.0; 



input double            DCADistancePips = 1.0; 

input double            HedgeDistancePips = 1.0; 

input int               MaxDCAOrders = 8; 

input int               MaxHedgeOrders = 8; 

input double            InitialLot = 0.01; 

input double            LotMultiplier = 2.0; 



input double            KB1_Profit = 20.0; 

input double            KB2_Profit = 10.0; 

input double            KB3_Profit = 8.0; 

input double            KB4_Profit = 5.0; 

input double            KB5_LossPips = 6.0; 

input double            KB6_ReversePips = 4.0; 

input double            KB7_Profit = 10.0; 



input double            KB8_Profit = 20.0; 

input double            KB9_Profit = 10.0; 

input double            KB10_Profit = 8.0; 

input double            KB11_Profit = 5.0; 

input double            KB12_LossPips = 6.0; 

input double            KB13_ReversePips = 4.0; 

input double            KB14_Profit = 10.0; 



input bool              KB15_UseNewsFilter = true; 

input int               KB15_NewsFilterMinutes = 30; 



input bool              KB16_UseTimeFilter = true; 

input int               KB16_TimeFilterMinutes = 30; 



input bool              KB19_UseAccountStopLoss = true; 

input double            KB19_AccountStopLossAmount = -100.0; 



CTrade              trade;

CPositionInfo       posInfo;

CDealInfo    dealInfo;



int                 st_handle = INVALID_HANDLE;

int                 at_handle = INVALID_HANDLE;

double              st_buffer[];

double              at_buffer[];



ENUM_INITIAL_TRADE  g_initialTradeType = NONE;

double              g_initialTradePrice = 0.0;

double              g_kb_profit[20]; 

bool                g_tradeDisabled = false;

bool                g_eaStopped = false;



//+------------------------------------------------------------------+

int OnInit()

{

    trade.SetExpertMagicNumber(MagicNumber);

    trade.SetTypeFilling(ORDER_FILLING_FOK);

    trade.SetDeviationInPoints(10);



    if(UseSuperTrend)

    {

        st_handle = iCustom(_Symbol, _Period, InpSuperTrendIndicatorName, ST_Period, ST_Multiplier);

        if(st_handle == INVALID_HANDLE)

        {

            Print("Error creating SuperTrend indicator handle");

            return(INIT_FAILED);

        }

        ArraySetAsSeries(st_buffer, true);

    }



    if(UseAlphaTrend)

    {

        at_handle = iCustom(_Symbol, _Period, InpAlphaTrendIndicatorName, AT_Period, AT_Multiplier);

        if(at_handle == INVALID_HANDLE)

        {

            Print("Error creating AlphaTrend indicator handle");

            return(INIT_FAILED);

        }

        ArraySetAsSeries(at_buffer, true);

    }

    

    ArrayInitialize(g_kb_profit, 0.0);

    UpdateDashboard();

    

    return(INIT_SUCCEEDED);

}

//+------------------------------------------------------------------+

void OnDeinit(const int reason)

{

    if(st_handle != INVALID_HANDLE) IndicatorRelease(st_handle);

    if(at_handle != INVALID_HANDLE) IndicatorRelease(at_handle);

    Comment("");

}

//+------------------------------------------------------------------+

void OnTick()

{

    if(g_eaStopped)

    {

        Comment("EA Stopped (KB19 Triggered)");

        return;

    }



    CheckGlobalFilters();

    UpdateDashboard();



    if(g_tradeDisabled) return;



    int totalPositions = PositionsTotal();

    int myPositions = 0;

    for(int i = totalPositions - 1; i >= 0; i--)

    {

        if(posInfo.SelectByIndex(i))

        {

            if(posInfo.Symbol() == _Symbol && posInfo.Magic() == MagicNumber)

            {

                myPositions++;

            }

        }

    }



    if(TradingMode == SINGLE_MODE && Single_Mode_Enabled)

    {

        ManageSingleTrade(myPositions);

    }

    else if(TradingMode == DCA_MODE)

    {

        ManageDCATrades(myPositions);

    }

}

//+------------------------------------------------------------------+

void ManageSingleTrade(int posCount)

{

    if(posCount > 0)

    {

        for(int i = PositionsTotal() - 1; i >= 0; i--)

        {

            if(!posInfo.SelectByIndex(i)) continue;

            if(posInfo.Symbol() != _Symbol || posInfo.Magic() != MagicNumber) continue;

            

            double sl = posInfo.StopLoss();

            double tp = posInfo.TakeProfit();

            double openPrice = posInfo.PriceOpen();

            double pips_sl = NormalizePips(Single_SL_Pips);

            double pips_tp = NormalizePips(Single_TP_Pips);

            double pips_be = NormalizePips(Single_BreakEvenPips);

            

            if(posInfo.PositionType() == POSITION_TYPE_BUY)

            {

                if(sl == 0 || sl != openPrice - pips_sl)

                    trade.PositionModify(posInfo.Ticket(), openPrice - pips_sl, tp);

                if(tp == 0 || tp != openPrice + pips_tp)

                    trade.PositionModify(posInfo.Ticket(), sl, openPrice + pips_tp);

                    

                if(SymbolInfoDouble(_Symbol, SYMBOL_ASK) > openPrice + pips_be && sl != openPrice)

                {

                    trade.PositionModify(posInfo.Ticket(), openPrice, tp);

                }

            }

            else if(posInfo.PositionType() == POSITION_TYPE_SELL)

            {

                if(sl == 0 || sl != openPrice + pips_sl)

                    trade.PositionModify(posInfo.Ticket(), openPrice + pips_sl, tp);

                if(tp == 0 || tp != openPrice - pips_tp)

                    trade.PositionModify(posInfo.Ticket(), sl, openPrice - pips_tp);



                if(SymbolInfoDouble(_Symbol, SYMBOL_BID) < openPrice - pips_be && sl != openPrice)

                {

                    trade.PositionModify(posInfo.Ticket(), openPrice, tp);

                }

            }

        }

    }

    else

    {

        int signal = GetSignal();

        OpenInitialTrade(signal, true);

    }

}

//+------------------------------------------------------------------+

void ManageDCATrades(int posCount)

{

    if(posCount == 0)

    {

        g_initialTradeType = NONE;

        g_initialTradePrice = 0.0;

        

        int signal = GetSignal();

        OpenInitialTrade(signal, false);

    }

    else

    {

        if(g_initialTradeType == NONE)

        {

            FindInitialTrade();

        }



        if(g_initialTradeType != NONE)

        {

            CheckGridOpening();

            CheckGridClosing();

        }

    }

}

//+------------------------------------------------------------------+

void CheckGridOpening()

{

    int buyCount = 0;

    int sellCount = 0;

    double lastBuyPrice = 0.0;

    double lastSellPrice = 0.0;

    double highestBuy = 0.0;

    double lowestSell = 999999.0;

    

    for(int i = PositionsTotal() - 1; i >= 0; i--)

    {

        if(!posInfo.SelectByIndex(i)) continue;

        if(posInfo.Symbol() != _Symbol || posInfo.Magic() != MagicNumber) continue;

        

        if(posInfo.PositionType() == POSITION_TYPE_BUY)

        {

            buyCount++;

            if(posInfo.PriceOpen() > highestBuy) highestBuy = posInfo.PriceOpen();

            if(posInfo.Time() > GetLastOrderTime(POSITION_TYPE_BUY)) lastBuyPrice = posInfo.PriceOpen();

        }

        else if(posInfo.PositionType() == POSITION_TYPE_SELL)

        {

            sellCount++;

            if(posInfo.PriceOpen() < lowestSell) lowestSell = posInfo.PriceOpen();

            if(posInfo.Time() > GetLastOrderTime(POSITION_TYPE_SELL)) lastSellPrice = posInfo.PriceOpen();

        }

    }

    

    if(lastBuyPrice == 0.0 && buyCount > 0) lastBuyPrice = highestBuy;

    if(lastSellPrice == 0.0 && sellCount > 0) lastSellPrice = lowestSell;



    double dcaDist = NormalizePips(DCADistancePips);

    double hedgeDist = NormalizePips(HedgeDistancePips);

    double currentAsk = SymbolInfoDouble(_Symbol, SYMBOL_ASK);

    double currentBid = SymbolInfoDouble(_Symbol, SYMBOL_BID);

    

    if(g_initialTradeType == BUY_A)

    {

        double nextDCALot = InitialLot * MathPow(LotMultiplier, buyCount);

        double nextHedgeLot = InitialLot * MathPow(LotMultiplier, sellCount);

        

        if(currentAsk >= lastBuyPrice + dcaDist && buyCount < MaxDCAOrders)

        {

            trade.Buy(nextDCALot, _Symbol, 0, 0, 0, "DCA Buy");

        }

        

        double hedgeTriggerPrice = (sellCount == 0) ? g_initialTradePrice : lastSellPrice;

        if(currentBid <= hedgeTriggerPrice - hedgeDist && sellCount < MaxHedgeOrders)

        {

            trade.Sell(nextHedgeLot, _Symbol, 0, 0, 0, "Hedge Sell");

        }

    }

    else if(g_initialTradeType == SELL_A)

    {

        double nextDCALot = InitialLot * MathPow(LotMultiplier, sellCount);

        double nextHedgeLot = InitialLot * MathPow(LotMultiplier, buyCount);



        if(currentBid <= lastSellPrice - dcaDist && sellCount < MaxDCAOrders)

        {

            trade.Sell(nextDCALot, _Symbol, 0, 0, 0, "DCA Sell");

        }

        

        double hedgeTriggerPrice = (buyCount == 0) ? g_initialTradePrice : lastBuyPrice;

        if(currentAsk >= hedgeTriggerPrice + hedgeDist && buyCount < MaxHedgeOrders)

        {

            trade.Buy(nextHedgeLot, _Symbol, 0, 0, 0, "Hedge Buy");

        }

    }

}

//+------------------------------------------------------------------+

void CheckGridClosing()

{

    int buyCount = 0;

    int sellCount = 0;

    double totalProfit = 0.0;

    double highestBuy = 0.0;

    double lowestSell = 999999.0;



    for(int i = PositionsTotal() - 1; i >= 0; i--)

    {

        if(!posInfo.SelectByIndex(i)) continue;

        if(posInfo.Symbol() != _Symbol || posInfo.Magic() != MagicNumber) continue;



        totalProfit += posInfo.Profit() + posInfo.Swap();

        

        if(posInfo.PositionType() == POSITION_TYPE_BUY)

        {

            buyCount++;

            if(posInfo.PriceOpen() > highestBuy) highestBuy = posInfo.PriceOpen();

        }

        else if(posInfo.PositionType() == POSITION_TYPE_SELL)

        {

            sellCount++;

            if(posInfo.PriceOpen() < lowestSell) lowestSell = posInfo.PriceOpen();

        }

    }



    double currentAsk = SymbolInfoDouble(_Symbol, SYMBOL_ASK);

    double currentBid = SymbolInfoDouble(_Symbol, SYMBOL_BID);

    double pips_kb5 = NormalizePips(KB5_LossPips);

    double pips_kb6 = NormalizePips(KB6_ReversePips);

    double pips_kb12 = NormalizePips(KB12_LossPips);

    double pips_kb13 = NormalizePips(KB13_ReversePips);



    if(g_initialTradeType == SELL_A)

    {

        if(sellCount == 1 && buyCount == 0 && totalProfit >= KB1_Profit) CloseAllTrades(1);

        else if(sellCount == 1 && buyCount > 0 && totalProfit >= KB2_Profit) CloseAllTrades(2);

        else if(sellCount == 2 && buyCount > 0 && totalProfit >= KB3_Profit) CloseAllTrades(3);

        else if((sellCount == 3 || sellCount == 4) && buyCount > 0 && totalProfit >= KB4_Profit) CloseAllTrades(4);

        else if((sellCount == 2 || sellCount == 3) && buyCount >= 7 && currentBid <= highestBuy - pips_kb5) CloseAllTrades(5);

        else if(sellCount >= 6 && currentAsk >= lowestSell + pips_kb6) CloseAllTrades(6);

        else if(buyCount == 5 && sellCount == 5 && (currentAsk >= g_initialTradePrice || totalProfit >= KB7_Profit)) CloseAllTrades(7);

    }

    else if(g_initialTradeType == BUY_A)

    {

        if(buyCount == 1 && sellCount == 0 && totalProfit >= KB8_Profit) CloseAllTrades(8);

        else if(buyCount == 1 && sellCount > 0 && totalProfit >= KB9_Profit) CloseAllTrades(9);

        else if(buyCount == 2 && sellCount > 0 && totalProfit >= KB10_Profit) CloseAllTrades(10);

        else if((buyCount == 3 || buyCount == 4) && sellCount > 0 && totalProfit >= KB11_Profit) CloseAllTrades(11);

        else if((buyCount == 2 || buyCount == 3) && sellCount >= 7 && currentAsk >= lowestSell + pips_kb12) CloseAllTrades(12);

        else if(buyCount >= 6 && currentBid <= highestBuy - pips_kb13) CloseAllTrades(13);

        else if(buyCount == 5 && sellCount == 5 && (currentBid <= g_initialTradePrice || totalProfit >= KB14_Profit)) CloseAllTrades(14);

    }

}

//+------------------------------------------------------------------+

void CheckGlobalFilters()

{

    if(KB19_UseAccountStopLoss && !g_eaStopped)

    {

        if(AccountInfoDouble(ACCOUNT_EQUITY) <= AccountInfoDouble(ACCOUNT_BALANCE) + KB19_AccountStopLossAmount)

        {

            CloseAllTrades(19);

            g_eaStopped = true;

            Print("KB19 Account StopLoss Triggered. EA Stopped.");

        }

    }

    

    g_tradeDisabled = false;

    

    if(KB16_UseTimeFilter)

    {

        MqlDateTime dt;

        TimeCurrent(dt);

        int minutes_to_eod = (23 - dt.hour) * 60 + (59 - dt.min);

        int minutes_from_sod = dt.hour * 60 + dt.min;

        

        if(minutes_to_eod <= KB16_TimeFilterMinutes)

        {

            if(PositionsTotal() > 0) CloseAllTrades(16);

            g_tradeDisabled = true;

        }

        else if(minutes_from_sod <= KB16_TimeFilterMinutes)

        {

            g_tradeDisabled = true;

        }

    }



    if(KB15_UseNewsFilter)

    {

        if(CheckForNews())

        {

             if(PositionsTotal() > 0) CloseAllTrades(15);

             g_tradeDisabled = true;

        }

    }

}

//+------------------------------------------------------------------+

bool CheckForNews()

{

    return false;

}

//+------------------------------------------------------------------+

void CloseAllTrades(int kb_scenario)

{

    string comment = "KB" + (string)kb_scenario;

    for(int i = PositionsTotal() - 1; i >= 0; i--)

    {

        if(posInfo.SelectByIndex(i))

        {

            if(posInfo.Symbol() == _Symbol && posInfo.Magic() == MagicNumber)

            {

                trade.PositionClose(posInfo.Symbol());

            }

        }

    }

    g_initialTradeType = NONE;

    g_initialTradePrice = 0.0;

}

//+------------------------------------------------------------------+

int GetSignal()

{

    double st_val = 0.0;

    double at_val = 0.0;

    int st_signal = 0;

    int at_signal = 0;



    if(UseSuperTrend)

    {

        if(CopyBuffer(st_handle, 0, 1, 1, st_buffer) > 0)

        {

            st_val = st_buffer[0];

            if(st_val > 0) st_signal = 1; 

            else if(st_val < 0) st_signal = -1;

        }

    }

    

    if(UseAlphaTrend)

    {

         if(CopyBuffer(at_handle, 0, 1, 1, at_buffer) > 0)

         {

            at_val = at_buffer[0];

            if(at_val > 0) at_signal = 1; 

            else if(at_val < 0) at_signal = -1;

         }

    }



    if(!UseSuperTrend && UseAlphaTrend) return at_signal;

    if(UseSuperTrend && !UseAlphaTrend) return st_signal;

    if(!UseSuperTrend && !UseAlphaTrend) return 0;

    

    if(SignalMode == ONE_INDICATOR)

    {

        if(st_signal != 0) return st_signal;

        if(at_signal != 0) return at_signal;

    }

    else if(SignalMode == TWO_INDICATORS)

    {

        if(st_signal == 1 && at_signal == 1) return 1;

        if(st_signal == -1 && at_signal == -1) return -1;

    }



    return 0;

}

//+------------------------------------------------------------------+

void OpenInitialTrade(int signal, bool singleMode)

{

    if(signal == 0) return;

    

    double sl = 0.0;

    double tp = 0.0;

    double price = 0.0;

    double delay_pips = 0.0;



    if(signal == 1)

    {

        delay_pips = NormalizePips(BuyEntryDelayPips);

        price = SymbolInfoDouble(_Symbol, SYMBOL_ASK) + delay_pips;

        

        if(singleMode)

        {

            sl = price - NormalizePips(Single_SL_Pips);

            tp = price + NormalizePips(Single_TP_Pips);

        }



        if(BuyEntryDelayPips == 0)

            trade.Buy(InitialLot, _Symbol, 0, sl, tp, "Lệnh A Buy");

        else if(BuyEntryDelayPips > 0)

            trade.BuyStop(InitialLot, price, _Symbol, sl, tp, 0, 0, "Lệnh A BuyStop");

        else

            trade.BuyLimit(InitialLot, price, _Symbol, sl, tp, 0, 0, "Lệnh A BuyLimit");

            

        if(trade.ResultRetcode() == 10009 || trade.ResultRetcode() == 10008)

        {

            g_initialTradeType = BUY_A;

            g_initialTradePrice = (BuyEntryDelayPips == 0) ? trade.ResultPrice() : price;

        }

    }

    else if(signal == -1)

    {

        delay_pips = NormalizePips(SellEntryDelayPips);

        price = SymbolInfoDouble(_Symbol, SYMBOL_BID) + delay_pips;

        

        if(singleMode)

        {

            sl = price + NormalizePips(Single_SL_Pips);

            tp = price - NormalizePips(Single_TP_Pips);

        }

        

        if(SellEntryDelayPips == 0)

            trade.Sell(InitialLot, _Symbol, 0, sl, tp, "Lệnh A Sell");

        else if(SellEntryDelayPips > 0)

            trade.SellLimit(InitialLot, price, _Symbol, sl, tp, 0, 0, "Lệnh A SellLimit");

        else

            trade.SellStop(InitialLot, price, _Symbol, sl, tp, 0, 0, "Lệnh A SellStop");



        if(trade.ResultRetcode() == 10009 || trade.ResultRetcode() == 10008)

        {

            g_initialTradeType = SELL_A;

            g_initialTradePrice = (SellEntryDelayPips == 0) ? trade.ResultPrice() : price;

        }

    }

}

//+------------------------------------------------------------------+

void FindInitialTrade()

{

    ulong firstTicket = 0;

    long firstTime = LONG_MAX;



    for(int i = PositionsTotal() - 1; i >= 0; i--)

    {

        if(!posInfo.SelectByIndex(i)) continue;

        if(posInfo.Symbol() != _Symbol || posInfo.Magic() != MagicNumber) continue;

        

        if(posInfo.Time() < firstTime)

        {

            firstTime = posInfo.Time();

            firstTicket = posInfo.Ticket();

        }

    }

    

    if(posInfo.SelectByTicket(firstTicket))

    {

        g_initialTradePrice = posInfo.PriceOpen();

        if(posInfo.PositionType() == POSITION_TYPE_BUY)

            g_initialTradeType = BUY_A;

        else

            g_initialTradeType = SELL_A;

    }

}

//+------------------------------------------------------------------+

long GetLastOrderTime(ENUM_POSITION_TYPE type)

{

    long lastTime = 0;

    for(int i = PositionsTotal() - 1; i >= 0; i--)

    {

        if(!posInfo.SelectByIndex(i)) continue;

        if(posInfo.Symbol() == _Symbol && posInfo.Magic() == MagicNumber && posInfo.PositionType() == type)

        {

            if(posInfo.Time() > lastTime) lastTime = posInfo.Time();

        }

    }

    return lastTime;

}

//+------------------------------------------------------------------+

double NormalizePips(double pips)

{

    double point = _Point;

    if(_Digits == 3 || _Digits == 5)

    {

        return pips * 10 * point;

    }

    return pips * point;

}

//+------------------------------------------------------------------+

void UpdateDashboard()

{

    MqlDateTime dt;

    TimeCurrent(dt);

    datetime today_start = StructToTime(dt) - (dt.hour * 3600 + dt.min * 60 + dt.sec);

    datetime today_end = today_start + 86400;



    ArrayInitialize(g_kb_profit, 0.0);

    

    HistorySelect(today_start, today_end);

    

    for(int i = 0; i < HistoryDealsTotal(); i++)

    {

        if(dealInfo.SelectByIndex(i))

        {

            if(dealInfo.Magic() == MagicNumber && dealInfo.Symbol() == _Symbol && dealInfo.Entry() == DEAL_ENTRY_OUT)

            {

                string comment = dealInfo.Comment();

                if(StringFind(comment, "KB") == 0)

                {

                    string kb_num_str = StringSubstr(comment, 2);

                    int kb_num = (int)StringToInteger(kb_num_str);

                    if(kb_num >= 1 && kb_num <= 19)

                    {

                        g_kb_profit[kb_num] += dealInfo.Profit();

                    }

                }

            }

        }

    }

    

    string dashboard = "Robot Tuan Anh - SuperTrend\n";

    dashboard += "--- Thong ke Loi Nhuan Hom Nay ---\n";

    for(int i = 1; i <= 19; i++)

    {

        dashboard += StringFormat("KB %d: $%.2f", i, g_kb_profit[i]);

        if(i % 7 == 0) dashboard += "\n";

        else dashboard += " | ";

    }

    

    Comment(dashboard);

}

//+------------------------------------------------------------------+
